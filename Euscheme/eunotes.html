<html>
<head>
<title>Euscheme Starter Notes</title>
</head>

<body bgcolor="#cdcd00">
<center>
<h2><font color="#aa0000">Using Euscheme</font></h2><p>
<a href="http://www.bath.ac.uk/~masrjb">Russell Bradford</a>
</center><p><p>

<h3><font color="#aa0000">0. Introduction</font></h3><p>

<a href="http://www.bath.ac.uk/~masrjb/Sources/euscheme.html">Euscheme</a>
is a simple
<a href="http://www.bath.ac.uk/~masjap/eulisp.html">EuLisp</a> Level 0
interpreter, and is used as the language for
several of the assignments in final year courses. EuLisp Level 0 is a small and
compact Lisp, but nevertheless has many interesting features, such as modules,
an object system, and multithreading.  EuLisp Level 1 has extra features, the
most notable being a full metaobject system.

These are a few notes on the use of Euscheme. We assume you are already
familiar with Lisp, so we concentrate on those things unique to Eulisp.<p>

There is a basic "teach yourself Lisp"
<A href="http://www.bath.ac.uk/~masjap/TYL">course</a>, you might like to look
at: it even contains a few self assessment exercises.<p>

<h3><font color="#aa0000">1. Running Euscheme</font></h3><p>

Just type 
<tt><font color="#004400">euscheme</font></font></tt>
and that will do it. You get something like
<pre><font color="#004400">EuScheme - Version 0.30s

user>
</font></pre>
where the final line is the prompt. Euscheme uses the usual read-eval-print
cycle of interactive Lisps: type something, it will be evaluated, and the
result printed.

To exit, use
<pre><font color="#004400">(exit)
</font></pre>
and (<a href="#ctrld">usually</a>) 
<tt><font color="#004400">^D</font></tt>
will work, too.<p>

<h3><font color="#aa0000">2. Constants</font></h3><p>
There are the usual self-evaluating bits and pieces:
<ul>
<li> strings: in double quotes 
<tt><font color="#004400">"hello"</font></tt>
<li> numbers: integers and floating point 
<tt><font color="#004400">1234</font></tt>
and 
<tt><font color="#004400">3.1415</font></tt>
<li> characters: preceded by 
<tt><font color="#004400">#\</font></tt>
as in
<tt><font color="#004400">#\c</font></tt>
for the character 'c'
<li> vectors: delimited by 
<tt><font color="#004400">#(</font></tt>
and
<tt><font color="#004400">)</font></tt>
as in 
<tt><font color="#004400">#(1 a (3))</font></tt>
which is a vector of length 3, containing an integer, a
symbol, and a list.
</ul>

<h3><font color="#aa0000">3. Lists and Vectors</font></h3><p>
Lists are created with the usual 
<tt><font color="#004400">cons</font></tt>,
<tt><font color="#004400">list</font></tt>
and quoted forms 
<tt><font color="#004400">'(1 2 3)</font></tt>.
Use 
<tt><font color="#004400">car</font></tt>
and 
<tt><font color="#004400">cdr</font></tt>
to access the elements.<p>

A vector is created by the function 
<tt><font color="#004400">make-vector</font></tt>
as in
<pre><font color="#004400">(make-vector 4)
</font></pre>
which creates a vector of length 4, indexed from 0 to 3, all elements
initialised to be 
<tt><font color="#004400">()</font></tt>s.
In fact,
<tt><font color="#004400">make-vector</font></tt>
can take a second argument
<pre><font color="#004400">(make-vector 4 0)
</font></pre>
which creates a vector as before, with all elements initialised to 0.<p>

To access a vector element use 
<tt><font color="#004400">(vector-ref vec index)</font></tt>;
to update use 
<tt><font color="#004400">((setter vector-ref) vec index newval)</font></tt>.
See <a href="#setter">below</a> for details about the 
<tt><font color="#004400">setter</font></tt>
function.<p>

Take care with the creation of vectors: 
<tt><font color="#004400">(make-vector 3 #(0 0 0))</font></tt>
will create a vector of three slots, all initialised to the <em>same</em>
(<tt><font color="#004400">eq</font></tt>)
value.<p>

<h3><font color="#aa0000">4. Expressions</font></h3><p>
As is usual, anything that is not a constant is an expression to be evaluated,
and those things marked by a quote are deemed to be constant.  Thus
<pre><font color="#004400">(+ 1 2)
</font></pre>
is an expression to be evaluated, while
<pre><font color="#004400">'(+ 1 2)
</font></pre>
is the constant list of 3 elements.

EuLisp has both 
<tt><font color="#004400">progn</font></tt>
to collect together several expressions into a single expression, and 
<tt><font color="#004400">let</font></tt>
for the declaration of local variables.
<pre><font color="#004400">(progn
  expr
  expr
  ...
)
</font></pre>
and
<pre><font color="#004400">(let ((var val)
      (var val)
      ...)
  expr
  expr
  ...
)
</font></pre>
(Semantics: evaluate all the 
<tt><font color="#004400">val</font></tt>s
first, then make the bindings to the corresponding 
<tt><font color="#004400">val</font></tt>s.
Thus the
<tt><font color="#004400">val</font></tt>s
cannot refer to the 
<tt><font color="#004400">vars</font></tt>s.
Use 
<tt><font
color="#004400">let*</font></tt>
<pre><font color="#004400">(let* ((var1 val1)
       (var2 val2)
       ...)
  ...)
</font></pre>
with semantics of evaluate 
<tt><font color="#004400">val1</font></tt>,
bind to
<tt><font color="#004400">var1</font></tt>,
evaluate 
<tt><font color="#004400">val2</font></tt>,
bind to 
<tt><font color="#004400">var2</font></tt>,
etc., if you need to refer back to previous values.)<p>

The values of these expressions are the values of their last
<tt><font color="#004400">expr</font></tt>s.<p>

Numbers have the usual syntaxes:
<tt><font color="#004400">123</font></tt>,
<tt><font color="#004400">1.23</font></tt> and
<tt><font color="#004400">1.2e4</font></tt>.  Additionally, you can enter
integers in base 2:
<tt><font color="#004400">#b101010</font></tt>,
base 8:
<tt><font color="#004400">#o7654</font></tt>,
base 16:
<tt><font color="#004400">#x12ab</font></tt>,
and any other base up to 36:
<tt><font color="#004400">#23r12gd</font></tt> for a base 23 integer.<p>

The full syntax of symbols is somewhat tricky, but "alphanumerics, starting
with a letter" is certainly OK.  Dodgy characters, such as space, or a leading
digit can be escaped with a
<tt><font color="#004400">\</font></tt>.  A multiple character escape is
introduced and ended by
<tt><font color="#004400">|</font></tt>.  Within the confines of these
delimeters any character is fine, except that
<tt><font color="#004400">\|</font></tt>
is interpreted as a literal 
<tt><font color="#004400">|</font></tt>,
and
<tt><font color="#004400">\\</font></tt>
as a literal
<tt><font color="#004400">\</font></tt>.<p>

All the following are the same symbol:
<pre><font color="#004400">\1\ 23
|1 |23
|1 23|
|1 |2|3|
|1 |2\3
\1| |2||3
</font></pre>
Their canonical form is
<tt><font color="#004400">|1 23|</font></tt>.

<h3><font color="#aa0000">5. Conditionals</font></h3><p>
EuLisp has the usual 
<tt><font color="#004400">(if boolexpr trueexpr falseexpr)</font></tt>
(always with both 
<tt><font color="#004400">trueexpr</font></tt>
and 
<tt><font color="#004400">falseexpr</font></tt>), and the 
<tt><font color="#004400">cond</font></tt>
form.  The single false value in EuLisp is 
<tt><font color="#004400">()</font></tt>:
anything else is deemed to be true.  The symbol
<tt><font color="#004400">nil</font></tt>
is bound to 
<tt><font color="#004400">()</font></tt>,
while 
<tt><font color="#004400">t</font></tt>
is bound to the symbol 
<tt><font color="#004400">t</font></tt>,
providing a convenient canonical true value.

Additional conditional forms include
<pre><font color="#004400">(when boolexpr
   expr
   expr
   ...
)
</font></pre>
where the 
<tt><font color="#004400">expr</font></tt>s
are evaluated when the condition is true; and
<pre><font color="#004400">(unless boolexpr
   expr
   expr
   ...
)
</font></pre>
where the 
<tt><font color="#004400">expr</font></tt>s
are evaluated when the
condition is false.<p>

<h3><font color="#aa0000">6. Assignment</font></h3><p>
You've got 
<tt><font color="#004400">setq</font></tt>.
It's also good to define your global variables
<pre><font color="#004400">(deflocal foo 2)
</font></pre>
somewhere, too. You can omit the initial value if you want.  The
<tt><font color="#004400">deflocal</font></tt>
form should only be used at the top level (i.e., never inside a function
definition or a
<tt><font color="#004400">let</font></tt>).<p>

<h3><font color="#aa0000">7. Defining Functions</font></h3><p>
Here we use 
<tt><font color="#004400">defun</font></tt>.
<pre><font color="#004400">(defun len (l)
  (if (null l)
      0
      (+ 1 (len (cdr l)))))
</font></pre>

EuLisp is fully tail-recursive, so a function written in a tail-recursive way
uses no stack:
<pre><font color="#004400">(defun foo (n)
  (print n)
  (foo (+ n 1)))
</font></pre>
will run forever.<p>

Variable arity functions are available, too:
<pre><font color="#004400">(defun bar (a b . c)
  (list a b c))
</font></pre>
can take 2 or more arguments.  The first two arguments are bounds to 
<tt><font color="#004400">a</font></tt>
and 
<tt><font color="#004400">b</font></tt>
as usual, the rest are made into a list which is bound to
<tt><font color="#004400">c</font></tt>.
Thus 
<tt><font color="#004400">(bar 1 2 3 4 5)</font></tt>
prints 
<tt><font color="#004400">(1 2 (3 4 5))</font></tt>,
and
<tt><font color="#004400">(bar 99 100)</font></tt>
prints 
<tt><font color="#004400">(99 100 ())</font></tt><p>

<h3><font color="#aa0000">8. Arithmetic</font></h3><p>
All the usual stuff here. Functions 
<tt><font color="#004400">+</font></tt>,
<tt><font color="#004400">-</font></tt>,
<tt><font color="#004400">*</font></tt>
and 
<tt><font color="#004400">/</font></tt>,
<tt><font color="#004400">abs</font></tt>,
<tt><font color="#004400">sin</font></tt>,
<tt><font color="#004400">exp</font></tt>
and so on. Use
<tt><font color="#004400">(pow a b)</font></tt>
to raise 
<tt><font color="#004400">a</font></tt>
to power 
<tt><font color="#004400">b</font></tt>.
Additionally, the basic arithmetic ops have variable arity:
<pre><font color="#004400">(+)         -> 0
(+ 1)       -> 1
(+ 1 2)     -> 3
(+ 1 2 3)   -> 6
(- 1)       -> -1
(* 1 2 3 4) -> 24
</font></pre>
and so on.<p>

<h3><font color="#aa0000">9. Modules</font></h3><p>
Now for something a little different.  The basic unit of a program in EuLisp is
the <em>module</em>.  Modules provide a way of fixing the global namespace
pollution problem: each module has its very own namespace.  A module can
import names from other modules, and can export names too.<p>

Here is a simple module:
<pre><font color="#004400">(defmodule one
  (import (level0))

  (defun foo ...)
  (defun bar ...)
  (deflocal baz ...)
  ...

  (export foo baz)
)
</font></pre>
The module 
<tt><font color="#004400">one</font></tt>
<em>import</em>s from the system module named
<tt><font color="#004400">level0</font></tt>.
This module contains all the useful stuff like 
<tt><font color="#004400">cons</font></tt>,
<tt><font color="#004400">car</font></tt>,
<tt><font color="#004400">defun</font></tt>,
<tt><font color="#004400">+</font></tt>
and so on.  In fact, it's generally a good idea to import the 
<tt><font color="#004400">level0</font></tt>
module, otherwise you can't actually do anything.<p>

In module 
<tt><font color="#004400">one</font></tt>
we define a few name, like
<tt><font color="#004400">foo</font></tt>,
<tt><font color="#004400">bar</font></tt>
and 
<tt><font color="#004400">baz</font></tt>,
and <em>export</em> 
<tt><font color="#004400">foo</font></tt>
and 
<tt><font color="#004400">baz</font></tt>.
Now any module that imports 
<tt><font color="#004400">one</font></tt>
can access
<tt><font color="#004400">foo</font></tt>
and 
<tt><font color="#004400">baz</font></tt>,
but 
<tt><font color="#004400">bar</font></tt>
is completely hidden from everyone.<p>

If now, we have
<pre><font color="#004400">(defmodule two
  (import (level0 one))

  ...
)
</font></pre>
the module 
<tt><font color="#004400">two</font></tt>
imports 
<tt><font color="#004400">one</font></tt>
(and 
<tt><font color="#004400">level0</font></tt>), so
<tt><font color="#004400">two</font></tt>
can refer to 
<tt><font color="#004400">foo</font></tt>
and 
<tt><font color="#004400">baz</font></tt>
from 
<tt><font color="#004400">one</font></tt>.
If 
<tt><font color="#004400">two</font></tt>
uses a name 
<tt><font color="#004400">bar</font></tt>,
it is its own 
<tt><font color="#004400">bar</font></tt>,
and has nothing to do with the 
<tt><font color="#004400">bar</font></tt>
in
<tt><font color="#004400">one</font></tt>.<p>

<h4><font color="#aa0000">Modules in Euscheme</font></h4>
Euscheme requires each module to be in a file of its own: thus 
<tt><font color="#004400">one</font></tt>
should be in a file named 
<tt><font color="#004400">one.em</font></tt>
(for <em>E</em>uLisp <em>m</em>odule), and 
<tt><font color="#004400">two</font></tt>
in 
<tt><font color="#004400">two.em</font></tt>.

To enter a module, use
<pre><font color="#004400">(!> one)
</font></pre>
which will load 
<tt><font color="#004400">one</font></tt>
if it is not already loaded, and will set the current module to be 
<tt><font color="#004400">one</font></tt>.
This is indicated by the prompt
<pre><font color="#004400">user> (!> one)
&lt;reading one.em>
&lt;read one.em>
&lt;one...done>
#t
one>
</font></pre>
Now the read-eval-print loop acts on bindings in the 
<tt><font color="#004400">one</font></tt>
module. Use 
<tt><font color="#004400">(!> user)</font></tt>
to switch back to the original module.<p>

To re-load a module (after, say, changing the file) use 
<tt><font color="#004400">(!>> one)</font></tt>.<p>

<h3><font color="#aa0000">10. Errors and the Debug Loop</font></h3><p>
When you make an error, EuLisp will call an <em>error handler</em>.  The full
use of error handlers is too tricky for an introductory set of notes, so we
shall rely on the default (built-in) handler.  In Euscheme an error
puts the system into a simple debugging loop:
<pre><font color="#004400">user> qwerty
Continuable error---calling default handler:
Condition class is #&lt;class unbound-error>
message:        "variable unbound in module 'user'"
value:          qwerty

Debug loop.  Type help: for help
Broken at #&lt;Code #1008a768>

DEBUG>
</font></pre>
There is a lot of information here, and you should look carefully at what
Euscheme is telling you.<p>

In this case, the call of error is an 'unbound-error', i.e., reference to an
undefined variable. The 
<tt><font color="#004400">message</font></tt>
gives an English description of the error, while the 
<tt><font color="#004400">value</font></tt>
fills in some details, so it is the variable named 
<tt><font color="#004400">qwerty</font></tt>
that is at fault.<p>

Another error:
<pre><font color="#004400">user> (car 5)
Continuable error---calling default handler:
Condition class is #&lt;class bad-type>
message:        "incorrect type in car"
value:          5
expected-type:  #&lt;class cons>

Debug loop.  Type help: for help
Broken at #&lt;Code #100820a8>

DEBUG>
</font></pre>
This is a 'bad-type' error, where the function 
<tt><font color="#004400">car</font></tt>
was expecting a different type of argument; it got a 
<tt><font color="#004400">5</font></tt>,
where it was expecting something of class 
<tt><font color="#004400">cons</font></tt>,
i.e., some sort of list.<p>

The prompt becomes 
<tt><font color="#004400">DEBUG></font></tt>
to indicate we are in the debug loop. In this loop things act as normal, except
we have some additional functions to play with. Type 
<tt><font color="#004400">help:</font></tt>
to get
<pre><font color="#004400">Debug loop.
top:                                return to top level
resume:  or  (resume: val)          resume from error
bt:                                 backtrace
locals:                             local variables
cond:                               current condition
up:  or  (up: n)                    up one or n frames
down:  or  (down: n)                down one or n frames
where:                              current function
</font></pre>
The most useful of these is 
<tt><font color="#004400">top:</font></tt>,
which
clears up the error and returns us to the top-level read-eval-print loop; and 
<tt><font color="#004400">bt:</font></tt>
which gives us a backtrace, i.e., a list of the function calls and their
arguments that took us to where we are now.  (Note that, as EuLisp is tail
recursive, Euscheme does not save all the return addresses of the functions
that it travels through, so the backtrace may omit certain intermediate
function calls.)<p>

In a debug loop <a name="ctrld"></a>
<tt><font color="#004400">^D</font></tt>
will act as 
<tt><font color="#004400">resume:</font></tt>,
which is to try to carry on from the point of error.  Debug loops can be
nested.<p>

<h3><font color="#aa0000">11. Classes and Generic Functions</font></h3><p>
EuLisp has a full object system. At Level 0, it is a simple, non-reflective
system, comparable to C++'s class system.

Every object in EuLisp has a class, which is itself a first-class object:
this means that classes are supported at the same level as any other object in
the system, and can be created, passed to functions, returned from functions,
and so on.  For example, the integer 
<tt><font color="#004400">1</font></tt>
has class 
<tt><font color="#004400">&lt;integer></font></tt>
(or rather, has a class with <em>name</em> 
<tt><font color="#004400">&lt;integer></font></tt>).<p>

In fact, Euscheme has 
<tt><font color="#004400">(class-of 1)</font></tt>
to be
<tt><font color="#004400">&lt;fpi></font></tt>
(for
<em>f</em>ixed <em>p</em>oint <em>i</em>nteger), which is a subclass of
<tt><font color="#004400">&lt;integer></font></tt>.<p>

Classes are fully-fledged objects, so they have a class, too
<pre><font color="#004400">(class-of &lt;integer>) -> #&lt;class class>
</font></pre>
the print representation of the class 
<tt><font color="#004400">&lt;class></font></tt>.
Finally,
<tt><font color="#004400">(class-of &lt;class>)</font></tt>
is 
<tt><font color="#004400"> &lt;class></font></tt>
itself, or else we would need an infinite tower of classes.<p>

To make an instance of a class, use 
<tt><font color="#004400">make</font></tt>
<pre><font color="#004400">(make &lt;cons> car: 1 cdr: 2) -> (1 . 2)
</font></pre>
The keywords (symbols whose names end with colons) indicate how to fill in the
various slots of the instance of the class. The keywords can be in any order,
and can be omitted if not necessary: though some classes have slots with
<em>required</em> keywords.  This means that instances of such classes
<em>must</em> have certain information passed to 
<tt><font color="#004400">make</font></tt>
in order to succeed.<p>

The function 
<tt><font color="#004400">make</font></tt>
is defined in terms of functions
<tt><font color="#004400">allocate</font></tt><a name="initialize"></a>
and
<tt><font color="#004400">initialize</font></tt>.
The former allocates an instance of the class in question, while the latter
initialises it (fill in slots or whatever else is necessary).  At Level 0,
only
<tt><font color="#004400">initialize</font></tt>
is a generic function, and so only the initialisation phase can be
specialised.<p>

Some classes are <em>abstract</em>, and you cannot make instances of them.
They are there purely for other classes to inherit from. The class
<tt><font color="#004400">&lt;list></font></tt>
is abstract, while its subclass
<tt><font color="#004400">&lt;cons></font></tt>
is
<em>concrete</em>.<p>

It is simple to create new classes by the use of 
<tt><font color="#004400">defclass</font></tt>.
<pre><font color="#004400">(defclass &lt;rat> ()
   ((num keyword: num:
         default: 0
         accessor: num)
    (den keyword: den:
         default: 1
         accessor: den))
    predicate: rat?
    constructor: (rat num: den:))
</font></pre>
There are many parts to explain.<p>

This form defines a new class named 
<tt><font color="#004400">&lt;rat></font></tt>.
Classes in EuLisp are conventionally noted by the use of angle brackets 
<tt><font color="#004400">&lt;></font></tt>,
but they are just normal names. The 
<tt><font color="#004400">()</font></tt>
next is the list of classes for

<tt><font color="#004400">&lt;rat></font></tt>
to inherit from.  In EuLisp Level 0, there is only single inheritance, so this
should be a list of at most one class.  Any empty list indicates some suitable
default superclass.<p>

Next is a list of <em>slot descriptions</em>.  Each has a slot name first, then
a list of <em>slot options</em>. The slot options are identified by keywords
which can come in any order, and can be omitted it you don't want them.<p>

The slot options are
<ul>
<li> 
<tt><font color="#004400">keyword:</font></tt>
a keyword to use in a
<tt><font color="#004400">make</font></tt>
of the class instance.
<li> 
<tt><font color="#004400">default:</font></tt>
a default value to put in the slot if a value is not passed via the keyword.
<li> 
<tt><font color="#004400">accessor:</font></tt>
a name that will be bound to functions to read and write the slot.  In the
above example,
<tt><font color="#004400">num</font></tt>
will name a function to read the 
<tt><font color="#004400">num</font></tt>
slot in an instance of
<tt><font color="#004400">&lt;rat></font></tt>.
Similarly,
<tt><font color="#004400">(setter num)</font></tt>
will be a function to write
to such a slot. See
<a href="#setter">setters</a>.
<li> 
<tt><font color="#004400">reader:</font></tt>
a name for a slot reader.
<li> 
<tt><font color="#004400">writer:</font></tt>
a name for a slot writer.
<li> 
<tt><font color="#004400">requiredp:</font></tt>
use 
<tt><font color="#004400">requiredp: t</font></tt>
to indicate a required slot. This slot must have a 
<tt><font color="#004400">keyword:</font></tt>
keyword!
</ul>
The 
<tt><font color="#004400">accessor:</font></tt>,
<tt><font color="#004400">reader:</font></tt>
and 
<tt><font color="#004400">writer:</font></tt>
options can be repeated as many times as you wish with different names.<p>

Next come the class options. Again, in any order or omitted.
<ul>
<li> 
<tt><font color="#004400">predicate:</font></tt>
a symbol to name a function that will return true on an instance of the class,
and false on all other objects.
<li> 
<tt><font color="#004400">constructor:</font></tt>
a way to name a function to make an instance of the class.  In this case, 
<tt><font color="#004400">rat</font></tt>
will name a function of two arguments that makes an instance of 
<tt><font color="#004400">&lt;rat></font></tt>.
The first argument will be given to the
<tt><font color="#004400">num:</font></tt>
keyword, the second to the
<tt><font color="#004400">den:</font></tt>.
This is equivalent to defining
<pre><font color="#004400">(defun rat (n d)
  (make &lt;rat> num: n den: d))
</font></pre>
As usual, you can reorder or leave out bits as you feel.
<li>
<tt><font color="#004400">keywords: t</font></tt>
with a list of extra keywords (above those defined in the slot descriptions)
that this class allows.  Usually you would use these extra keywords in
specialised methods on
<a href="#initialize"><tt><font color="#004400">initialize</font></tt></a>.
<li> 
<tt><font color="#004400">abstractp: t</font></tt>
to indicate that this class is abstract, and no direct instances can be made.
</ul>
The class options 
<tt><font color="#004400">predicate:</font></tt>
and
<tt><font color="#004400">constructor:</font></tt>
can be
repeated.<p>

To see all the currently defined classes in Euscheme use
<tt><font color="#004400">(class-hierarchy)</font></tt>.
Other useful functions include
<tt><font color="#004400">class-superclasses</font></tt>,
<tt><font color="#004400">class-subclasses</font></tt>
and
<tt><font color="#004400">class-slots</font></tt>.<p>

<h4><font color="#aa0000">Generic Functions</font></h4>
Generic functions are (again) first-class objects in EuLisp, constructed by 
<tt><font color="#004400">defgeneric</font></tt>.
Methods are added to them by 
<tt><font color="#004400">defmethod</font></tt>
(unlike some other systems, a generic function must be created by
<tt><font color="#004400">defgeneric</font></tt>
<em>before</em> 
<tt><font color="#004400">defmethod</font></tt>
will work.)

<pre><font color="#004400">(defgeneric foo (a b))

(defmethod foo ((a &lt;integer>) (b &lt;integer>))
  (list 'int 'int))

(defmethod foo ((x &lt;float>) (y &lt;float>))
  (list 'float 'float))
</font></pre>
This defines a generic of two arguments, and two methods. So
<pre><font color="#004400">(foo 4 5)     -> (int int)
(foo 1.0 2.0) -> (float float)
(foo 2 2.0)   -> error, "no applicable methods"
</font></pre>
The methods discriminate off all the arguments, working left to right. Adding
another method
<pre><font color="#004400">(defmethod foo ((n &lt;number>) (m &lt;number>))
  (list 'num 'num))
</font></pre>
we get 
<tt><font color="#004400">(foo 2 2.0) -> (num num)</font></tt>.

Generally the most specific method for a given set of arguments is the method
that is executed in a generic call.  The next most specific method can be
invoked by using 
<tt><font color="#004400">(call-next-method)</font></tt>
in the body of the current method.<p>

<h3><font color="#aa0000">12. Threads</font></h3><p>
EuLisp supports multiple threaded programming by supplying some basic
thread primitives.<p>

To make a thread use
<pre><font color="#004400">(make-thread fn)
</font></pre>
which returns a thread object (another first-class object).  The 
<tt><font color="#004400">fn</font></tt>
is the function that the thread will start executing when it and when starts
running.<p>

A thread will not run until it is <em>started</em>
<pre><font color="#004400">(thread-start thr arg arg ...)
</font></pre>
This function takes a thread 
<tt><font color="#004400">thr</font></tt>
and starts executing the function
<tt><font color="#004400">fn</font></tt>
(from 
<tt><font color="#004400">make-thread</font></tt>)
on the arguments 
<tt><font color="#004400">arg</font></tt>.
That is, it starts executing 
<tt><font color="#004400">(fn arg arg ...)</font></tt>.<p>

Or it would start executing the thread if there were enough processors
to do so.  As is most likely, the thread is simply marked as <em>ready to
run</em> whenever the resource is available.  The EuLisp model requires
the programmer to write in such a manner that does not presume any particular
number of processors are available.  Even if there is just one processor, the
program should be written to work. To aid this, there is the function
<pre><font color="#004400">(thread-reschedule)
</font></pre>
which will suspend the current thread, and allow another to run in its place.
If there are enough processors so that all threads are running, then
<tt><font color="#004400">thread-reschedule</font></tt>
could have no effect at all.<p>

An single-threaded implementation such as Euscheme requires a sprinkling of
<tt><font color="#004400">thread-reschedule</font></tt>s
for a parallel program to work.<p>

Threads are often used for their effect, but they can also return a value.
<pre><font color="#004400">(thread-value thr)
</font></pre>
will suspend the calling thread (and allow another to run in its place) until
the thread 
<tt><font color="#004400">thr</font></tt>
returns a value (and returns what the 
<tt><font color="#004400">thr</font></tt>
returned).  A thread can return a value simply by returning from its initial
function
(<tt><font color="#004400">fn</font></tt>, above).<p>

<h4><font color="#aa0000">Semaphores</font></h4>
EuLisp provides simple binary semaphores, named <em>locks</em>, with functions

<tt><font color="#004400">make-lock</font></tt>
to make one, 
<tt><font color="#004400">lock</font></tt>
to gain a semaphore, and
<tt><font color="#004400">unlock</font></tt>
to release.<p>

Locking a locked lock will suspend the calling thread (and allow another to
run) until some other thread releases the lock.<p>

<h3><font color="#aa0000">13. Input and Output</font></h3><p>

EuLisp is still a little undecided as to how i/o is going to turn out, so for
the meantime Euscheme uses Scheme's functions.
<ul>
<li> 
<tt><font color="#004400">read</font></tt>
to read a Lisp expression.
<li> 
<tt><font color="#004400">write</font></tt>
output in a way that can be re-read if possible. Thus, for example, strings are
quoted.
<li> 
<tt><font color="#004400">prin</font></tt>
output in a human-friendly manner. Strings and such are not quoted. Compare
<pre><font color="#004400">(print "asd")   prints: asd
(write "asd")   prints: "asd"
</font></pre>
<li> 
<tt><font color="#004400">print</font></tt>
as 
<tt><font color="#004400">prin</font></tt>,
with a newline.
<li> 
<tt><font color="#004400">newline</font></tt>
output a newline.
</ul>
All of the above take an optional extra argument, which is a stream to print
on. This defaults to the standard output.<p>

For stream manipulation:
<ul>
<li> 
<tt><font color="#004400">open-input-file</font></tt>
takes a string, and opens and returns a corresponding stream for input. Returns
<tt><font color="#004400">()</font></tt>
if not such file exists.
<li> 
<tt><font color="#004400">open-output-file</font></tt>
creates a file if it didn't already exist.
<li> 
<tt><font color="#004400">open-update-file</font></tt>
opens for append.
<li> 
<tt><font color="#004400"> get-file-position</font></tt>
and 
<tt><font color="#004400">(setter  get-file-position)</font></tt>
move the file pointer in a file opened for update.
<li> 
<tt><font color="#004400">close-port</font></tt>
closes an open stream.
</ul>

<h4><font color="#aa0000">Format</font></h4>
A more complicated printing function is 
<tt><font color="#004400">format</font></tt>,
which is somewhat akin to C's 
<tt><font color="#004400">printf</font></tt>.

<pre><font color="#004400">(format stream format-string arg arg ...)
</font></pre>
If 
<tt><font color="#004400">stream</font></tt>
is 
<tt><font color="#004400">t</font></tt>,

<tt><font color="#004400">format</font></tt>
prints to the standard output. If 
<tt><font color="#004400">stream</font></tt>
is 
<tt><font color="#004400">()</font></tt>,

<tt><font color="#004400">format</font></tt>
returns the formatted output as a string. Otherwise 
<tt><font color="#004400">stream</font></tt>
is a file stream.<p>

The format string is copied to the output, except that 
<tt><font color="#004400">~</font></tt>
marks an escape (like C's 
<tt><font color="#004400">%</font></tt>):
<ul>
<li> 
<tt><font color="#004400">~a</font></tt>
output the next arg using
<tt><font color="#004400">prin</font></tt>
<li> 
<tt><font color="#004400">~s</font></tt>
output the next arg using
<tt><font color="#004400">write</font></tt>
<li> 
<tt><font color="#004400">~%</font></tt>
output a newline
<li> 
<tt><font color="#004400">~~</font></tt>
output a 
<tt><font color="#004400">~</font></tt>
<li> 
<tt><font color="#004400">~c</font></tt>
output a character
<li> 
<tt><font color="#004400">~d</font></tt>
output an integer
<li> 
<tt><font color="#004400">~e</font></tt>
<tt><font color="#004400">~f</font></tt>,
<tt><font color="#004400">~g</font></tt>
floating point formats
<li> 
<tt><font color="#004400">~t</font></tt>
output a tab
</ul>
There are other escapes to write integers in other bases, output new pages, and
so on.<p>

<h3><font color="#aa0000">14. Macros</font></h3><p>

EuLisp employs the usual backquoted template style of macros.
<pre><font color="#004400">(defmacro first (x)
  `(car ,x))
</font></pre>
Note that a macro cannot be used in the module where it is defined: a module
must be fully macroexpanded before it can be compiled. If you don't know what
is and what isn't a macro beforehand, it is very difficult to do this. Thus
a module containing
<pre><font color="#004400">(defmacro second (x)
   `(cadr ,x))

(defun foo (x) (+ 1 (second x)))
</font></pre>
is doomed to failure by this restriction.<p>

There is a wrinkle in the way that macros interact with modules: suppose a
macro expands into something that refers to bindings that are not imported into
the current module?

<pre><font color="#004400">(defmodule one
  (import (level0))

  (defmacro foo (x)
     `(car (bar ,x)))

  (defun bar (a) ...)

  (export foo)
)
</font></pre>
Here the module 
<tt><font color="#004400">one</font></tt>
exports 
<tt><font color="#004400">foo</font></tt>
only, but 
<tt><font color="#004400">foo</font></tt>
expands into a reference to 
<tt><font color="#004400">bar</font></tt>.
<pre><font color="#004400">(defmodule two
  (import (level0))

  ...
  (foo 4)
  ...
)
</font></pre>
In the macroexpansion of module 
<tt><font color="#004400">two</font></tt>,
a reference to 
<tt><font color="#004400">bar</font></tt>
would appear, but 
<tt><font color="#004400">bar</font></tt>
is not defined in
<tt><font color="#004400">two</font></tt>.
Worse, maybe
<tt><font color="#004400">bar</font></tt>
<em>was</em> defined in 
<tt><font color="#004400">two</font></tt>:
which 
<tt><font color="#004400">bar</font></tt>
does the macroexpanded form refer to? The 
<tt><font color="#004400">bar</font></tt>
from
<tt><font color="#004400">one</font></tt>
or the
<tt><font color="#004400">bar</font></tt>
from 
<tt><font color="#004400">two</font></tt>?<p>

The answer is "the right 
<tt><font color="#004400">bar</font></tt>", that is
that 
<tt><font color="#004400">bar</font></tt>
in the module of macro definition, not the 
<tt><font color="#004400">bar</font></tt>
in the module of macro use.  Euscheme takes care of all of this transparently
for you: essentially every symbol remembers which module it was defined in, and
always refers back to that module for its value.<p>

This provides a simple solution to the "macro hygene" problem that
has always plagued Lisp macros.<p>

Sometimes you <em>do</em> want a symbol to be captured in the module
of use: Euscheme provides a facility to allow you to do this.
<pre><font color="#004400">(defmacro while (test . body)
  `(let/cc {break}
     (labels
       ((loop ()
	  (when ,test
                ,@body
                (loop))))
       (loop))))
</font></pre>
The symbol 
<tt><font color="#004400">loop</font></tt>
cannot be captured by the code in 
<tt><font color="#004400">body</font></tt>,
while the symbol 
<tt><font color="#004400">break</font></tt>
is intended to be captured. The curly braces about the symbol
indicates that it is to be interpreted as coming from the module of
use, <em>not</em> the module of definition. Thus, a reference to
<tt><font color="#004400">break</font></tt>
in the 
<tt><font color="#004400">body</font></tt>
will refer to the binding in the
<tt><font color="#004400">let/cc</font></tt>.<p>

Notice that <tt><font color="#004400">(eq 'break '{break}) -> t</font></tt>.
As symbols they are <tt><font color="#004400">eq</font></tt>, but as
identifiers they are quite different.

<h3><font color="#aa0000">15. Miscellany</font></h3><p>

<h4><font color="#aa0000">Comparisons</font></h4>
EuLisp has the usual tests for equality:
<ul>
<li> 
<tt><font color="#004400">eq</font></tt>
for identity
<li> 
<tt><font color="#004400">eql</font></tt>
for identity, but will also work for integers and characters
<li> 
<tt><font color="#004400">equal</font></tt>
for recursive equality
<li> 
<tt><font color="#004400">=</font></tt>
for numbers
</ul>
Note that
<pre><font color="#004400">(equal 1 1.0)  -> ()
(= 1 1.0)      -> t
</font></pre>

There is also the usual 
<tt><font color="#004400">&lt;</font></tt>,
<tt><font color="#004400">&lt;=</font></tt>,
<tt><font color="#004400">></font></tt>,
<tt><font color="#004400">>=</font></tt>,
which are n-ary:
<pre><font color="#004400">(< a b c ...)
</font></pre>
returns 
<tt><font color="#004400">t</font></tt>
when 
<tt><font color="#004400">a</font></tt>,
<tt><font color="#004400">b</font></tt>,
<tt><font color="#004400">c</font></tt>,
etc., form a strictly increasing sequence. Similarly 
<tt><font color="#004400">&lt;=</font></tt>
for a non-decreasing sequence, and so on.<p>

<h4><font color="#aa0000">Generic Arithmetic</font></h4>
The arithmetic operators 
<tt><font color="#004400">+</font></tt>
and so on are all n-ary, i.e., take a variable number of arguments.  Each
operator is defined in terms of a binary generic function: 
<tt><font color="#004400">binary+</font></tt>
for 
<tt><font color="#004400">+</font></tt>,
<tt><font color="#004400">binary*</font></tt>
for
<tt><font color="#004400">*</font></tt>,
etc.  The n-ary form is just a repeated application of the binary form
<pre><font color="#004400">(+ a b c ...) = ((..(binary+ (binary+ a b) c) ...
</font></pre>

Methods can be added to the binary operators
<pre><font color="#004400">(defmethod binary+ ((a &lt;symbol>) (b &lt;symbol>))
   ...)
</font></pre>
and then you can use 
<tt><font color="#004400">+</font></tt>
to add symbols:
<tt><font color="#004400">(+ 'a 'b 'c)</font></tt>.<p>

There are also generic functions 
<tt><font color="#004400">unary-</font></tt>
and 
<tt><font color="#004400">unary/</font></tt>
for the unary 
<tt><font color="#004400">(- x)</font></tt>
and 
<tt><font color="#004400">(/ x)</font></tt>
(reciprocal).<p>

Similarly, the comparators 
<tt><font color="#004400">&lt;</font></tt>,
<tt><font color="#004400">></font></tt>,
<tt><font color="#004400">&lt;=</font></tt>
etc., are all defined in terms of the two generic functions 
<tt><font color="#004400">binary&lt;</font></tt>
and 
<tt><font color="#004400">binary=</font></tt>.<p>

<h4><font color="#aa0000">Local Functions</font></h4>
Just like 
<tt><font color="#004400">let</font></tt>
introduces local variables, the 
<tt><font color="#004400">labels</font></tt>
form can introduce local functions.
<pre><font color="#004400">(labels
  ((foo (a b)
     ... (bar a) ... )
   (bar (x)
     ... (foo x (bar x)) ... ))
  ...
  (foo 3 4)
  ...
)
</font></pre>
The 
<tt><font color="#004400">labels</font></tt>
takes a list of function definitions. They may be self and mutually recursive.
These functions may be used within the body of the 
<tt><font color="#004400">labels</font></tt>
just like global functions. Iterating functions are often most conveniently
written in terms of
<tt><font color="#004400">labels</font></tt>
as the bodies of the function definitions can refer to local variables:
<pre><font color="#004400">(let ((a 1))
  (labels
    ((addit (x)
       (if (null x)
           ()
           (cons (+ a (car x)) (addit (cdr x))))))
    (addit '(1 2 3))))
->
(2 3 4)
</font></pre>

<a name="map"></a>
<h4><font color="#aa0000">Mapping and Collections</font></h4>
There are several functions supplied to iterate along collections. Collections
include lists, vectors, strings, and <a href="#tables">tables</a>.<p>

The generic function
<tt><font color="#004400">map</font></tt>
takes a function and a collection
<pre><font color="#004400">(map list '(1 2 3))   -> ((1) (2) (3))
(map - #(4 5 6))      -> #(-4 -5 -6)
</font></pre>
or more than one collection
<pre><font color="#004400">(map cons '(a b c) '(A B C))     -> ((a . A) (b . B) (c . C))
(map + #(1 2 3) #(10 10 10 10))  -> #(11 12 13)
</font></pre>
The mapping stops when any collection runs out. Even a mixture will work
<pre><font color="#004400">(map * '(2 4 6) #(1 -1 1))  -> (2 -4 6)
(map * #(2 4 6) '(1 -1 1))  -> #(2 -4 6)
</font></pre>
The type of collection returned is the same as the first collection
argument.<p>

If you don't need a return value, but are iterating purely for effect, use
<tt><font color="#004400">do</font></tt>
<pre><font color="#004400">(do print '(1 2 3))
</font></pre>

Other iterators include 
<tt><font color="#004400">accumulate</font></tt>
<pre><font color="#004400">(accumulate list () #(a b c))      -> (((() a) b) c)
(accumulate * 1 '(1 2 3 4 5 6 7))  -> 5040
</font></pre>
which takes a function, an initial value, an a collection to iterate over.<p>

You can find the size of any collection using the function 
<tt><font color="#004400">size</font></tt>.
This returns the length of a list of string, number of elements of a vector,
and so on. It can be reversed by
<tt><font color="#004400">reverse</font></tt>;
an element removed by
<tt><font color="#004400">remove</font></tt>
(non-destructive) or by 
<tt><font color="#004400">delete</font></tt>
(destructive); find an element by 
<tt><font color="#004400">(member elt
collection)</font></tt>.
The last three
(<tt><font color="#004400">remove</font></tt>,
<tt><font color="#004400">delete</font></tt>
and 
<tt><font color="#004400">member</font></tt>)
take an optional last argument that is a test for equality: it is this test
that is used when looking for an element in the collection.  It defaults to 
<tt><font color="#004400">eql</font></tt>.<p>

The function 
<tt><font color="#004400">concatenate</font></tt>
can be used to join collections:
<pre><font color="#004400">(concatenate '(1 2 3) '(4 5 6))  -> (1 2 3 4 5 6)
(concatenate "abc" "def")        -> "abcdef"
(concatenate '(1 2 3) #(4 5 6))  -> (1 2 3 4 5 6)
</font></pre>

<h4><font color="#aa0000">Loops</font></h4>
EuLisp doesn't really need loops, as everything can be written easily in
terms of tail recursive functions. However, Euscheme sneaks in a 
<tt><font color="#004400">while</font></tt>
loop:
<pre><font color="#004400">(while bool
   expr
   expr
   ...
)
</font></pre>
which loops while the 
<tt><font color="#004400">bool</font></tt>
returns
true.<p>

<a name="tables"></a>
<h4><font color="#aa0000">Tables</font></h4>
EuLisp uses tables for a general association mechanism.  Euscheme
implements tables as hash tables, but in general they could be implemented
differently.
<ul>
<li> 
<tt><font color="#004400">make-table</font></tt>
returns a table.
<li> 
<tt><font color="#004400">(table-ref table key)</font></tt>
to retrieve a value,

<tt><font color="#004400">((setter table-ref) table key value)</font></tt>
to update.
<li> 
<tt><font color="#004400">(table-delete key)</font></tt>
to remove a value.
<li> 
<tt><font color="#004400">table-keys</font></tt>
to get a list of current keys.
<li> 
<tt><font color="#004400">table-values</font></tt>
to get a list of current values.
<li> 
<tt><font color="#004400">table-clear</font></tt>
to completely empty a table.
</ul>
When looking for a match to a key in a table, the system defaults to
<tt><font color="#004400">eql</font></tt>.
You can change this by using
<tt><font color="#004400">(make-table comparator)</font></tt>,
where 
<tt><font color="#004400">comparator</font></tt>
is 
<tt><font color="#004400">eq</font></tt>
or 
<tt><font color="#004400">eql</font></tt>
or
<tt><font color="#004400">equal</font></tt>
or 
<tt><font color="#004400">=</font></tt>.<p>

If a value is not found for a particular key in the table 
<tt><font color="#004400">()</font></tt>
is returned.  This can be changed by 
<tt><font color="#004400">(make-table
comparator fill-value)</font></tt>.
Now 
<tt><font color="#004400">fill-value</font></tt>
will be returned on failure.<p>

The mapping functions <a href="#map">above</a> work on tables, too.<p>

<h4><font color="#aa0000">Non-local exits</font></h4>
EuLisp supports a limited form of continuation capture via 
<tt><font color="#004400">let/cc</font></tt>.
This form captures its continuation, and allows its use as a non-local exit.
<pre><font color="#004400">(let/cc out
   ...
   (out)
   ...
)
;; after
</font></pre>
This stores the continuation (i.e., from 'after') in the variable 
<tt><font color="#004400">out</font></tt>.
This can be called as a function, whereupon control passes immediately to that
continuation. The value of 
<tt><font color="#004400">out</font></tt>
can only be used in this way in the dynamic scope of the 
<tt><font color="#004400">let/cc</font></tt>
form: outside the value is 'dead' and no longer usable.<p>

The continuation function can take a single optional argument which is a value
to pass to the continuation: the default is 
<tt><font color="#004400">()</font></tt>.<p>

The forms 
<tt><font color="#004400">block</font></tt>
and 
<tt><font color="#004400">return-from</font></tt>
are simply 
<tt><font color="#004400">let/cc</font></tt>
and a call to a continuation:
<pre><font color="#004400">(block foo
  ...
  (return-from foo)
  ...
)
</font></pre>

The 
<tt><font color="#004400">unwind-protect</font></tt>
form ensures things are executed even if there is a non-local exit
<pre><font color="#004400">(unwind-protect
  protected-form
  after-form
  after-form
  ...)
</font></pre>
This starts by executing the 
<tt><font color="#004400">protected-form</font></tt>.
If there is no unusual exit from the 
<tt><font color="#004400">protected-form</font></tt>,
this will then execute the 
<tt><font color="#004400">after-form</font></tt>s
and will return whatever value the
<tt><font color="#004400">protected-form</font></tt>
returned.  If there is a non-local exit from the 
<tt><font color="#004400">protected-form</font></tt>
to a continuation outside the
<tt><font color="#004400">unwind-protect</font></tt>,
the 
<tt><font color="#004400">after-form</font></tt>s
will <em>still</em> be executed before the control passes to the
continuation.<p>

<a name="setter"></a>
<h4><font color="#aa0000">Setters</font></h4>
Structures, like lists, vectors and class instances have elements that can
be accessed.  The elements of a vector can be read by 
<tt><font color="#004400">vector-ref</font></tt>.
To write to an element use the function 
<tt><font color="#004400">(setter vector-ref)</font></tt>,
<pre><font color="#004400">((setter vector-ref) vec index val)
</font></pre>

Similarly, the accessor 
<tt><font color="#004400">car</font></tt>
has an updater 
<tt><font color="#004400">(setter car)</font></tt>
(often called 
<tt><font color="#004400">rplaca</font></tt>
in other Lisps), and so on. In general a reader function  
<tt><font color="#004400">r</font></tt>
will have an associated updater 
<tt><font color="#004400">(setter r)</font></tt>.<p>

The function 
<tt><font color="#004400">setter</font></tt>
is a simple association mechanism: 
<tt><font color="#004400">setter</font></tt>
is a function that takes a reader and returns the associated writer. To make
such an association between functions
<tt><font color="#004400">r</font></tt>
and 
<tt><font color="#004400">w</font></tt>
just
use 
<tt><font color="#004400">setter</font></tt>
again
<pre><font color="#004400">((setter setter) r w)
</font></pre>
In fact, no particular properties of 
<tt><font color="#004400">r</font></tt>
and 
<tt><font color="#004400">w</font></tt>,
are used, so this can be used as a general facility. Further, 
<tt><font color="#004400">setter</font></tt>
functions, generic functions and methods can be defined directly:
<pre><font color="#004400">(defun (setter foo) (a b)
  ...)
</font></pre>

<h4><font color="#aa0000">Convert</font></h4>
The function 
<tt><font color="#004400">convert</font></tt>
is used to change an object of one type into an object of another type.  Thus
to convert an integer to a float
<pre><font color="#004400">(convert 1 &lt;float>) -> 1.0
</font></pre>
or the other way
<pre><font color="#004400">(convert 2.6 &lt;integer>) -> 2
</font></pre>
Many other conversions are available: integer to string; character to string;
string to number; symbol to string; list to vector; and so on.<p>

<h4><font color="#aa0000">Copying</font></h4>
There are two functions that copy structures: 
<tt><font color="#004400">deep-copy</font></tt>
and
<tt><font color="#004400">shallow-copy</font></tt>.
The second recursively descends a structure making copies of all the elements
in the structure; the first makes a single copy of the top-level structure, and
fills its slots will the existing elements:
<pre><font color="#004400">(setq a '((1 2) (3 4)))
(setq d (deep-copy a))
(eq a d)                  -> ()
(equal a d)               -> t
(eq (car a) (car d))      -> ()

(setq s (shallow-copy a))
(eq a s)                  -> ()
(equal a s)               -> t
(eq (car a) (car s))      -> t
</font></pre>

<h4><font color="#aa0000">Other Tools</font></h4>
Other tools that Euscheme provides:
<ul>
<li> 
<tt><font color="#004400">describe</font></tt>
gives a little information about an object, e.g.,

<tt><font color="#004400">(describe <integer>)</font></tt>
or 
<tt><font color="#004400">(describe 4)</font></tt>
<li> 
<tt><font color="#004400">trace</font></tt><a name="trace"></a>
can be used to print a message every time a function is entered or exited. Thus
<pre><font color="#004400">(trace foo)
</font></pre>
will describe the ins and outs of the function 
<tt><font color="#004400">foo</font></tt>. To untrace, use
<tt><font color="#004400">(untrace foo)</font></tt>.<p>
</ul>

Use
<tt><font color="#004400">(import "trace")</font></tt>
to load 
<tt><font color="#004400">trace</font></tt>.

<h3><font color="#aa0000">16. Euscheme Modules</font></h3><p>

Euscheme provides a few sample modules.

<h4><font color="#aa0000">Trace</font></h4>
The
<tt><font color="#004400">trace</font></tt>
module has been mentioned <a href="#trace">above</a>.

<h4><font color="#aa0000">Linda</font></h4>
The
<tt><font color="#004400">eulinda</font></tt>
module implements the Linda pool mechanism.
<ul>
<li>
<tt><font color="#004400">make-linda-pool</font></tt>
returns a new pool
<li>
<tt><font color="#004400">(linda-out pool tag val val ...)</font></tt>
writes the tuple
<tt><font color="#004400">(val val ...)</font></tt>
under the tag to the pool
<li>
<tt><font color="#004400">(linda-in pool tag pat pat ...)</font></tt>
attempts to read a tuple matching the pattern
<tt><font color="#004400">(pat pat ...)</font></tt>
from the pool.  If no matching tuple exists in the pool, the call will block
until such a tuple appears.  When found, the tuple is removed from the pool.
A pattern is
<ul>
<li> a literal value, to be matched exactly
<li>
<tt><font color="#004400">(? var)</font></tt>
to match any value, and assign the matched value to the variable
<li>
<tt><font color="#004400">?</font></tt>
to match any value, and to discard the result.
</ul>
<li>
<tt><font color="#004400">linda-read</font></tt>
as
<tt><font color="#004400">linda-in</font></tt>
but does not remove the tuple from the pool
<li>
<tt><font color="#004400">(linda-eval fun arg arg ...)</font></tt>
starts a new thread, running the function with the arguments.
</ul>
Debugging tools are
<tt><font color="#004400">print-linda-pool</font></tt>
to print the curent values in a pool, and
<tt><font color="#004400">(tril t)</font></tt>
to print some trace information as the system is running.<p>

The
<tt><font color="#004400">tag</font></tt>
must be a symbol or number.

<h4><font color="#aa0000">Modular Numbers</font></h4>
The module
<tt><font color="#004400">modular</font></tt>
is a simple implementation of modular integers. The function
<tt><font color="#004400">mod</font></tt>
constructs a modular number

<pre><font color="#004400">(setq a (mod 3 5))  -> #<3 mod 5>
(setq b (+ a a))    -> #<1 mod 5>
(/ a)               -> #<2 mod 5>
</font></pre>

<h4><font color="#aa0000">Scheme</font></h4>
This module,
<tt><font color="#004400">scheme</font></tt>,
provides a mostly-conformant Scheme environment.  It is probably not wise
to mix Scheme constructs, such as
<tt><font color="#004400">call/cc</font></tt>,
with EuLisp constructs, such as threads.

<h4><font color="#aa0000">Paralation Lisp</font></h4>
This emulates a paralation system. The module
<tt><font color="#004400">tpl</font></tt>
(for <em>t</em>iny <em>p</em>aralation <em>l</em>isp) exports
<ul>
<li>
<tt><font color="#004400">(make-paralation n)</font></tt>
to make a new paralation of size
<tt><font color="#004400">n</font></tt>.
This returns a index field of the new paralation.
<li>
<tt><font color="#004400">elwise</font></tt>
is the element-wise operator:
<pre><font color="#004400">(elwise (a b) (+ a b))
</font></pre>
where
<tt><font color="#004400">a</font></tt>
and
<tt><font color="#004400">b</font></tt>
are fields on the same paralation.
<li>
<tt><font color="#004400">(match field field)</font></tt>
to create a map between fields, and
<li>
<tt><font color="#004400">(move field map combine default)</font></tt>
to move a
<tt><font color="#004400">field</font></tt>
down a
<tt><font color="#004400">map</font></tt>,
using
<tt><font color="#004400">combine</font></tt>,
(a function taking an appropriate number of arguments) to combine
elements that end up at the same element of the target field, and
<tt><font color="#004400">default</font></tt>
as the default value for a field element that is not in the image of the map.
</ul>

<h4><font color="#aa0000">Values</font></h4>
This is an emulation of Scheme and Common Lisp's multiple values. The
module
<tt><font color="#004400">values</font></tt>
exports
<ul>
<li>
<tt><font color="#004400">(values val val ...)</font></tt>
as the basic multiple value return
<li>
<tt><font color="#004400">call-with-values</font></tt>
for the Scheme-like values:
<pre><font color="#004400">(call-with-values
  (lambda () ...)             ; a thunk returning values
  (lambda (a b c ...) ...))   ; that are passed here, bound
                              ; to a, b, etc.
</font></pre>
<li>
<tt><font color="#004400">multiple-value-setq</font></tt>;
<tt><font color="#004400">multiple-value-list</font></tt>;
<tt><font color="#004400">multiple-value-call</font></tt>;
<tt><font color="#004400">values-list</font></tt>;
<tt><font color="#004400">multiple-value-bind</font></tt> are all as in Common
Lisp.
</ul>
If you pass multiple values to a continuation that only expects a single
value you will probably get strange results.

<h4><font color="#aa0000">Sort</font></h4>
A fast stable merge sort. The module
<tt><font color="#004400">sort</font></tt>
exports
<tt><font color="#004400">sort</font></tt>
(non-destructive) and
<tt><font color="#004400">sort!</font></tt>
(destructive).
They are called as
<tt><font color="#004400">(sort l)</font></tt>,
where
<tt><font color="#004400">l</font></tt>
is a list of values to be sorted. The comparison operator used is
<tt><font color="#004400">&lt;</font></tt>.
Alternatively, you can use
<tt><font color="#004400">(sort l comp)</font></tt>,
where
<tt><font color="#004400">comp</font></tt>
is a comparator function.

<h3><font color="#aa0000">17. Euscheme functions</font></h3><p>
Here is a summary of the functions available in Euscheme. Not all of these
correspond to EuLisp.

<pre><font color="#004400">;; specials
   quote
   lambda
   delay
   let
   let*
   setq
   if
   cond
   progn
   and
   or
   let/cc
   while
   block
   return-from
   labels
   when
   unless
   export
   expose
   enter-module
   !>
   reenter-module
   !>>
   call-next-method
   next-method-p
   import
   generic-lambda
   method-lambda

;; defining forms
   defun
   defgeneric
   defmethod
   deflocal
   defconstant
   defmodule
   defmacro

;; list functions
   cons
   car
   cdr
   caar
   cadr
   cdar
   cddr
   caaar
   caadr
   cadar
   caddr
   cdaar
   cdadr
   cddar
   cdddr
   caaaar
   caaadr
   caadar
   caaddr
   cadaar
   cadadr
   caddar
   cadddr
   cdaaar
   cdaadr
   cdadar
   cdaddr
   cddaar
   cddadr
   cdddar
   cddddr
   list
   list*
   append
   last-pair
   length
   memv
   memq
   assv
   assq
   list-ref
   list-tail

;; symbol functions
   bound?
   symbol-value
   symbol-plist
   gensym
   get
   put

;; vector functions
   vector
   make-vector
   vector-length
   vector-ref

;; predicates
   null
   atom
   listp
   numberp
   booleanp
   consp
   symbolp
   keywordp
   complexp
   floatp
   double-float-p
   rationalp
   integerp
   charp
   stringp
   vectorp
   functionp
   portp
   input-port-p
   output-port-p
   objectp
   eof-object-p
   default-object-p
   eq
   eql
   equal

;; arithmetic functions
   +
   -
   *
   /
   %
   zerop
   positivep
   negativep
   oddp
   evenp
   truncate
   floor
   ceiling
   round
   random
   quotient
   remainder
   sin
   cos
   tan
   asin
   acos
   atan
   exp
   sqrt
   log

;; bitwise logical functions
   logand
   logior
   logxor
   lognot

;; string functions
   make-string
   string-length
   string-null?
   string-append
   string-ref
   substring

;; i/o functions
   read
   read-char
   read-byte
   read-short
   read-long
   write
   write-char
   write-byte
   write-short
   write-long
   prin
   print
   newline
   char-ready-p
   peek-char
   format

;; print control functions
   print-breadth
   print-depth

;; file i/o functions
   open-input-file
   open-output-file
   open-append-file
   open-update-file
   close-port
   close-input-port
   close-output-port
   get-file-position
   unlink
   current-input-port
   current-output-port

;; utility functions
   transcript-on
   transcript-off
   getarg
   prompt?
   exit
   compile
   decompile
   gc
   save
   restore

;; debugging functions
   trace-on
   trace-off

;; module functions
   module-symbols
   module-exports
   symbol-module
   current-module
   module-list
   unintern

;; telos
   allocate
   describe
   classp
   subclassp

;; tables
   make-table
   table-ref
   table-comparator
   table-delete
   table-length
   table-keys
   table-values
   table-fill
   table-clear

;; plus some others
   binary
   text
   not
   prin1
   princ
   t
   nil
   eval                 ; no guarantees this one will work
   else
   system
   getenv
   putenv
   tmpfile
   current-time
   ticks-per-second
   backtrace
   backtracep

;; threads
   &lt;thread>
   &lt;simple-thread>
   make-thread
   threadp
   thread-reschedule
   current-thread
   thread-kill
   thread-queue
   current-thread
   thread-start
   thread-value
   thread-state
   &lt;thread-condition>
   &lt;thread-error>
   &lt;thread-already-started>

   &lt;lock>
   &lt;simple-lock>
   make-lock
   lockp
   lock
   unlock
   &lt;lock-condition>
   &lt;lock-error>

   wait
   &lt;wait-condition>
   &lt;wait-error>

;; errors and handlers
   with-handler
   unwind-protect
   &lt;wrong-condition-class>
   signal
   error
   cerror

;; classes
   &lt;object>
   &lt;class>
   &lt;simple-class>
   &lt;list>
   &lt;cons>
   &lt;null>
   &lt;number>
   &lt;integer>
   &lt;fpi>
   &lt;float>
   &lt;double-float>
   &lt;symbol>
   &lt;keyword>
   &lt;string>
   &lt;simple-string>
   &lt;port>
   &lt;input-port>
   &lt;output-port>
   &lt;i/o-port>
   &lt;vector>
   &lt;simple-vector>
   &lt;char>
   &lt;simple-char>
   &lt;promise>
   &lt;table>
   &lt;hash-table>
   &lt;function>
   &lt;simple-function>
   &lt;subr>
   &lt;continuation>
   &lt;generic>
   &lt;simple-generic>
   &lt;method>
   &lt;simple-method>
   &lt;slot>
   &lt;local-slot>
   &lt;structure>

   generic-prin
   generic-write
   wait

   make
   initialize
   class-hierarchy

;; setter
   setter

;; converter
   converter
   convert
   &lt;conversion-condition>
   &lt;no-converter>

;; condition classes
   defcondition
   conditionp
   condition-message
   condition-value
   &lt;condition>
   &lt;telos-condition>
   &lt;telos-error>
   &lt;telos-general-error>
   &lt;telos-bad-ref>
   &lt;no-applicable-method>
   &lt;no-next-method>
   &lt;incompatible-method-domain>
   &lt;arithmetic-condition>
   &lt;arithmetic-error>
   &lt;error>
   &lt;general-error>
   &lt;bad-type>
   &lt;unbound-error>
   &lt;compilation-error>
   &lt;macro-error>
   &lt;syntax-error>
   &lt;user-interrupt>

;; generic arithmetic
   binary+
   binary-
   unary-
   binary*
   binary/
   unary/
   binary%
   binary-gcd
   gcd
   abs
   pow

;; comparisons
   equal
   binary&lt;
   binary=
   &lt;
   =
   >
   &lt;=
   >=
   max
   min
   assoc

;; macros
   defmacro
   quasiquote
   unquote
   unquote-splicing
   symbol-macro
   macroexpand
   macroexpand1
   syntax

;; collections and sequences
   &lt;collection-condition>
   &lt;collection-error>
   collectionp
   sequencep
   accumulate
   accumulate1
   allp
   anyp
   concatenate
   delete
   do
   element
   emptyp
   fill
   map
   member
   remove
   reverse  
   size

;; copying
   deep-copy
   shallow-copy

;; telos introspection
   class-of
   class-name
   class-superclasses
   class-precedence-list
   class-slots
   class-keywords
   class-subclasses
   class-instance-size
   class-abstract-p
   generic-name
   generic-args
   generic-optargs?
   generic-methods
   generic-cache1
   generic-cache2
   method-generic
   method-function
   method-domain
   add-method
   slot-name
   slot-keyword
   slot-default
   slot-required-p

;; other functions
   apply
   map-list
   load
   load-noisily
   force
</font></pre>

<a href="http://www.bath.ac.uk/~masrjb/Sources/eunotes.html">Here</a> is
the latest version of these notes.
</body>
</html>
